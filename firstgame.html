<!DOCTYPE html>
<html lang="en">
<head>
	<title>Thomas Scott's First NES Game Demo!</title>
	<link href="styles/programstyle.css" rel="stylesheet" type="text/css">
	<link rel = "shortcut icon" type="image/x-icon" href="images/tinyico.png">

	<!-- custom css for progress bar from: https://jqueryui.com/progressbar/ -->
	<link rel="stylesheet" href="scripts/jquery-ui-1.13.2.custom/jquery-ui.css">

	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="description" content="Learn ASM 6502 and NES Programming Here.">
	<meta property="og:image" content="images/ognes.png">
	<meta name="keywords" content="ASM 6502, learn asm 6502, nes programming, asm 6502 programming, 
	nintendo programming, program nintendo games, how to make nes games">

</head>

<body>
	
	<!-- "Skipnav" code idea courtesy of Mike Scott and jimthatcher.com/skipnav.htm-->
	<div class="skipnav"><a href="#maincontent">Skip to main content</a></div>
	<div id="grand-parent">
	<div class="openmenu">
		<a href = "index.html">
		<img id = "logo" src="images/neslogo.png" alt="logo" height="60px">
		<div class="title">6502 With Thomas</div>
		</a>
		<button class="toggle-mode js-toggle-mode"><span id="sunmoon" aria-hidden="true"></span></button>
		<ul>
			<li><a href="index.html" class="home">Home</a></li>
			<li><a href="hardware.html" class="hardware">Hardware Basics</a></li>
			<li><a href="coding.html" class="coding">Coding Basics</a></li>
			<li><a href="programs.html" class="programs" id="sample-parent">Sample Programs</a></li>
			<li><a href="commands.html" class="command">Command Table</a></li>
			<li><a href="resources.html" class="resources">Other Resources</a></li>
		</ul>
	</div><!-- Closing openmenu -->
	<div class="sampleprograms" id="submenu">
		<h2 class = "samplemenu">Sample Programs</h2>
		<ul>
				<li><a href="programs.html" class="hello">"Hello, World!"</a></li>
				<li><a href="graphics.html" class="graphics">Graphics on the NES</a></li>
				<li><a href="sound.html" class="sound">Sound on the NES</a></li>
				<li><a href="controllers.html" class = "input">Getting Controller Input</a></li>
				<li><a href="firstgame.html" class="firstgame">Your First Game!</a></li>
		</ul>
	</div><!-- Closing sampleprograms -->
	</div><!-- Closing grand-parent wrapper -->

	<h1 id = "maincontent"> Program #5: Your First Game - Birthday Blast!</h1>
	<div id="progresstext">
		<h2>Loading Javascript...</h2>
		<progress max="100" value="1" id="progressbar">
		</progress><!-- closing progressbar-->
	</div><!-- closing progresstext -->

	<img src="images/birthdayblastscrn.png" alt="birthday blast gameplay" title="Happy Birthday?">
	<p>
		All right, it's to get excited. We've put it in lots of time to get ready for the big day, and here it 
		is... the day we work together to make your first game on the NES. Exciting! The game we're going to 
		make is called <span class="important">Birthday Blast</span> It's very simple, but by coding it, it 
		should give you an idea as to how to make more complex games yourself. Are you ready to make your 
		first game? Let's do this!
		<noscript>
			(You can skip to an explanation of code by clicking below.)
			<a href="#explanation">Code explanation</a>
		</noscript>
	</p>

	<div id="accordion">
	<h1>Game Code</h1>
	<div>
	<pre><code>
	; Birthday Blast!
	; Â© Thomas Wesley Scott, 2023

	; Code starts at $C000.
	; org jump to $BFFO for header info


	org $BFF0
	db "NES",$1a
	db $1
	db $1
	db %00000000
	db %00000000
	db 0
	db 0,0,0,0,0,0,0

; Labels for variables
item_choices equ $00 	
player_pos equ $01		
player_buttons equ $02	
player_lives equ $03
playerscore_hi equ $04
playerscore_mid equ $05
playerscore_lo equ $06
tick_down equ $0F
tick_up equ $07
max_items equ $08
fall_frame_rate equ $09
temp_pos equ $0A
move_timer equ $0B
random_num1 equ $0C
random_num2 equ $0D
walk_animation equ $FF	

; Labels for music notes
A1 equ $00
As1 equ $01
Bb1 equ $01
B1 equ $02

C2 equ $03
Cs2 equ $04
Db2 equ $04
D2 equ $05
Ds2 equ $06
Eb2 equ $06
E2 equ $07
F2 equ $08
Fs2 equ $09
Gb2 equ $09
G2 equ $0A
Gs2 equ $0B
Ab2 equ $0B
A2 equ $0C
As2 equ $0D
Bb2 equ $0D
B2 equ $0E

C3 equ $0F
Cs3 equ $10
Db3 equ $10
D3 equ $11
Ds3 equ $12
Eb3 equ $12
E3 equ $13
F3 equ $14
Fs3 equ $15
Gb3 equ $15
G3 equ $16
Gs3 equ $17
Ab3 equ $17
A3 equ $18
As3 equ $19
Bb3 equ $19
B3 equ $1A

C4 equ $1B
Cs4 equ $1C
Db4 equ $1C
D4 equ $1D
Ds4 equ $1E
Eb4 equ $1E
E4 equ $1F
F4 equ $20
Fs4 equ $21
Gb4 equ $21
G4 equ $22
Gs4 equ $23
Ab4 equ $23
A4 equ $24
As4 equ $25
Bb4 equ $25
B4 equ $26

C5 equ $27
Cs5 equ $28
Db5 equ $28
D5 equ $29
Ds5 equ $2A
Eb5 equ $2A
E5 equ $2B
F5 equ $2C
Fs5 equ $2D
Gb5 equ $2D
G5 equ $2E
Gs5 equ $2F
Ab5 equ $2F
A5 equ $30
As5 equ $31
Bb5 equ $31
B5 equ $32

C6 equ $33
Cs6 equ $34
Db6 equ $34
D6 equ $35
Ds6 equ $36
Eb6 equ $36
E6 equ $37
F6 equ $38
Fs6 equ $39
Gb6 equ $39
G6 equ $3A
Gs6 equ $3B
Ab6 equ $3B
A6 equ $3C
As6 equ $3D
Bb6 equ $3D
B6 equ $3E

C7 equ $3F
Cs7 equ $40
Db7 equ $40
D7 equ $41
Ds7 equ $42
Eb7 equ $42
E7 equ $43
F7 equ $44
Fs7 equ $45
Gb7 equ $45
G7 equ $46
Gs7 equ $47
Ab7 equ $47
A7 equ $48
As7 equ $49
Bb7 equ $49
B7 equ $4A

C8 equ $4B
Cs8 equ $4C
Db8 equ $4C
D8 equ $4D
Ds8 equ $4E
Eb8 equ $4E
E8 equ $4F
F8 equ $50
Fs8 equ $51
Gb8 equ $51
G8 equ $52
Gs8 equ $53
Ab8 equ $53
A8 equ $54
As8 equ $55
Bb8 equ $55
B8 equ $56

C9 equ $57
Cs9 equ $58
Db9 equ $58
D9 equ $59
Ds9 equ $5A
Eb9 equ $5A
E9 equ $5B
F9 equ $5C
Fs9 equ $5D

sq_len equ $7A	; counter for square note duration
ct_note equ $7C  	; current note
note_num equ $7D	; number of current note


nmi_handler:
	pha
	php

	lda player_pos
	sta $0203 

	lda #$02
	sta $4014

	ldx ct_note
	cpx #0
	beq skip_note
	
play_note:
	jsr sound_frame

skip_note:


	jsr read_controller
	
	
	ldx move_timer
	inx
	stx move_timer


	ldx tick_down
	dex
	stx tick_down
	cpx #0
	bne chk_collisions
	
	jsr tick_updates
	

chk_collisions:	
	; Check collisions with either floor or player
	jsr collisions


chk_frame_rate:
	
	; Only move if fall_frame_rate = move_timer
	lda move_timer
	cmp fall_frame_rate
	

	bmi randomizer
	

	lda #0
	sta move_timer
	jsr move_items

	
randomizer:

	; "Random" number generators	
	lda random_num1
	clc
	adc player_pos
	clc
	adc item_choices
	clc
	adc player_lives
	clc
	adc tick_down
	sta random_num1	
	
	lda random_num2
	adc playerscore_lo
	clc
	adc playerscore_hi
	clc	
	adc tick_down
	clc
	adc tick_up
	clc
	adc fall_frame_rate
	sta random_num2

	plp
	pla
	rti
	

irq_handler:
	rti

start_game:
	sei		; Disable interrupts
	cld		; Clear decimal mode

	ldx #$ff	
	txs		; Set-up stack
	inx		; x is now 0
	stx $2000	; Disable/reset graphic options 
	stx $2001	; Make sure screen is off
	stx $4015	; Disable sound

	stx $4010	; Disable DMC (sound samples)
	lda #$40
	sta $4017	; Disable sound IRQ
	lda #0	
wait_vblank:
	bit $2002	; check PPU Status to see if
	bpl wait_vblank	; vblank has occurred.
	lda #0
clear_memory:		; Clear all memory info
	sta $0000,x
	sta $0100,x
	sta $0300,x
	sta $0400,x
	sta $0500,x
	sta $0600,x
	sta $0700,x
	lda #$FF
	sta $0200,x	; Load $FF into $0200 to 
	lda #$00	; hide sprites 
	inx		; x goes to 1, 2... 255
	cpx #$00	; loop ends after 256 times,
	bne clear_memory ; clearing all memory


wait_vblank2:
	bit $2002	; Check PPU Status one more time
	bpl wait_vblank2	; before we start loading in graphics	

	; Load palettes
	lda $2002
	ldx #$3F
	stx $2006
	ldx #$00
	stx $2006
copy_pal_loop:
	lda initial_palette,x
	sta $2007
	inx
	cpx #$20
	bcc copy_pal_loop


	lda $2002

	
	ldx #$02
	stx $4014

	ldx #0
sprite_load:
	lda sprites,x	; Load tiles, x and y attributes
	sta $0200,x
	inx
	cpx #$04
	bne sprite_load


; Setup background


	ldy #$FF
	lda $2002
	lda #$20
	sta $2006
	sta $09		; zero page - storing high byte here
	lda #$09
	sta $2006
	sta $08		; zero page - storing low byte here

bkgd_outer:
	
	ldx #0
bkgd:
	; 14 tiles, place them 20 times

	lda backgrounddata_walls,x
	sta $2007
	inx
	cpx #$0E
	bne bkgd

	lda $2002
	iny
	clc
	lda $08
	adc #32
	sta $08	
	lda $09
	adc #0	; if carry is set, should add to $09
	sta $09	

	sta $2006
	lda $08
	sta $2006

	cpy #$14
	bne bkgd_outer

; Load the floor of the house.

	ldx #0
	lda $2002
	lda #$22	; tile address is $2289
	sta $2006
	lda #$89	; low byte of $2289
	sta $2006
bkgd_floor:
	lda #$01	; Tile $01 is a brick
	sta $2007
	inx
	cpx #$0D	; We want 13 bricks total
	bne bkgd_floor


bkgd_words:		; "Happy Birthday!" tiles
	lda #$20
	sta $09
	lda #$2C
	sta $08

	lda $2002
	lda $09
	sta $2006
	lda $08
	sta $2006

	ldx #0
happy:
	
	lda backgrounddata_words,x
	sta $2007
	inx
	cpx #$05
	bne happy

	clc
	lda $08
	adc #32
	sta $08
	lda $2002
	lda $09
	sta $2006
	lda $08
	sta $2006
birthday:
	; do not reset x, keep going
	
	lda backgrounddata_words,x
	sta $2007
	inx
	cpx #$0E
	bne birthday

	lda $2002
	lda #$22
	sta $2006
	lda #$C3
	sta $2006
	ldx #0
lives_and_score:
	lda score_lives_tiles,x
	sta $2007
	inx
	cpx #5
	bne lives_and_score

	lda $2002
	lda #$22
	sta $2006
	lda #$E3
	sta $2006
	
score:
	lda score_lives_tiles,x
	sta $2007
	inx
	cpx #$F
	bne score

	; Reset scroll values
	lda $2002
	lda #$00
	sta $2005
	sta $2005
	

	ldx #0


; We are using sprites to show the number of lives
; because the tile used is the same as the player

score_sprites:
	lda score_sprite,x	; Load tiles, x and y attributes
	sta $0224,x
	inx
	cpx #$0C
	bne score_sprites


	; Initialization of game data


	lda #%11111111		; All cakes as options to start (0 is bomb)
	sta item_choices

	lda #$5A		; Player position
	sta player_pos 

	lda #3			; Start with 3 lives
	sta player_lives
	
	lda #29			; 29th tile is zero tile
	sta playerscore_lo
	sta playerscore_mid
	sta playerscore_hi

	lda #0
	sta tick_up		; Number of seconds passed 

	lda #60
	sta tick_down		; Frames in a second	

	lda #15			; Number of frames before
	sta fall_frame_rate	; items move down
	
	lda #0			; Used to determine when
	sta move_timer		; items should move down

	lda #1
	sta max_items		; Only 1 item falling at start

	lda #4
	sta walk_animation

	; First cake
	lda #$30
	sta $0204		; Store starting y-coord
	lda #5			; Tile # for cake
	sta $0205		; Store it as first falling item
	lda #$02
	sta $0206
	lda #$7F
	sta $0207		; Store starting x-coord


music_setup:
	; Initialization
	lda #$01
	sta $4015	; Turn on instruments
	lda #%11111111
	sta $4000	; Configure square 1
	lda #$00
	sta $4001	; Turn off sweeping on square 1

	
	; Load initial values
	; Then turn the screen on so music can play
	lda birthday_notes
	sta ct_note
	asl		; Double it since we're dealing with words	
	tax		; Put the value in x-register

	lda notes,x 	; Lower half of note
	sta $4002
	lda notes+1,x 	; Higher half of note
	sta $4003

	; Length of first note
	lda birthday_length	
	sta sq_len
	
	lda #0
	sta note_num	; Number of note starts at zero
	

	; turn screen on
	lda #%00011110
	sta $2001
	lda #$88
	sta $2000


forever:
	jmp forever


sound_frame:

	; This subroutine is only loaded via vblank
	; and only if there are still notes to play

	; Check first if a new note is needed
	; If not, we simply decrease counter
	; and move on

	lda sq_len
	bne decrease_count
	
	; sq_len is zero, so we
	; need a new note
	; Increase note counter
	ldx note_num	
	inx
	stx note_num
	

	lda birthday_notes,x
	sta ct_note
	
	; Make sure newest note is a note
	cmp #0
	bne new_note
	
silence:

	; Note is "zero", so stop music
	lda #0
	sta $4015
	rts

new_note:
	

	; Load up a new note		
	ldx note_num
	lda birthday_length,x
	sta sq_len	; Length of new note

	ldx ct_note

	txa
	asl		; Double value since using words
	tax		; Put back in x-register

	lda notes,x
	sta $4002
	lda notes+1,x
	sta $4003

decrease_count:
	ldx sq_len
	dex
	stx sq_len

	rts 		; exit subroutine


; Table of different notes and their values
notes:	
	dw $07F1, $0780, $0713 				; A1 to B1 ($00-$02)
	dw $06AD, $064D, $05F3, $059D, $054D, $0500	; C2 to F2 ($03-$08)
	dw $04B8, $0475, $0435, $03F8, $03BF, $0389 	; F#2 to B2 ($09-$0E)
	dw $0356, $0326, $02F9, $02CE, $02A6, $027F	; C3 to F3 ($0F-$15)
	dw $025C, $023A, $021A, $01FB, $01DF, $01C4 	; F#3 to B3 ($16-$1A)
	dw $01AB, $0193, $017C, $0167, $0151, $013F	; C4 to F4 ($1B-$20)
	dw $012D, $011C, $010C, $00FD, $00EF, $00E2	; F#4 to B4 ($20-$26)
	dw $00D2, $00C9, $00BD, $00B3, $00A9, $009F	; C5 to F5 ($27-$2C)
	dw $0096, $008E, $0086, $007E, $0077, $0070 	; F#5 to B5 ($2D-$32)
	dw $006A, $0064, $005E, $0059, $0054, $004F	; C6 to F6 ($33-$38)
	dw $004B, $0046, $0042, $003F, $003B, $0038 	; F#6 to B6 ($39-$3E)
	dw $0034, $0031, $002F, $002C, $0029, $0027	; C7 to F7 ($3F-$45)
	dw $0025, $0023, $0021, $001F, $001D, $001B 	; F#7 to B7 ($46-$4A)
	dw $001A, $0018, $0017, $0015, $0014, $0013	; C8 to F8 ($4B-$50)
	dw $0012, $0011, $0010, $000F, $000E, $000D 	; F#8 to B8 ($51-$56)
	dw $000C, $000C, $000B, $000A, $000A, $0009, $0008 ; C9 to F#9 ($57-$5D)

; Notes to the song ("Happy Birthday")
birthday_notes:
	db G3, G3, A3, G3, C4, B3
	db G3, G3, A3, G3, D4, C4
	db G3, G3, G4, E4, C4, B3, A3
	db F4, F4, E4, C4, D4, C4
	db 0 ; Zero indicates song is over

birthday_length:
	
	; 240 BPM -> 4 times a second -> 15 counts per quarter note
	db 30, 15, 45, 45, 45, 90
	db 30, 15, 45, 45, 45, 90
	db 30, 15, 45, 45, 45, 45, 90
	db 30, 15, 45, 45, 45, 105


; Walking Animation
animate_girl:
	lda walk_animation
	sec
	sbc #16		; Animation updates for every
	bmi move_girl	; 16 frames of walking (approx.)
	rts
move_girl:
	lda $0201
	beq walk_now
stand_now:
	lda #$00	; Standing tile
	sta $0201
	rts
walk_now:
	lda #$01	; Walking tile
	sta $0201
	rts

; Controller Input Reading
read_controller:
	lda #1		; Begin logging controller input
	sta $4016	; Controller 1
	lda #0		; Finish logging
	sta $4016	; Controller 1

	ldx #8
read_ctrl_loop:
	pha		; Put accumulator on stack
	lda $4016	; Read next bit from controller

	and #%00000011	; If button is active on 1st controller,
	cmp #%00000001	; this will set the carry
	pla		; Retrieve current button list from stack

	ror		; Rotate carry onto bit 7, push other
			; bits one to the right

	dex		
	bne read_ctrl_loop
	
	sta player_buttons	

check_right:
	lda player_buttons	; Load buttons
	and #%10000000		; Bit 7 is "right"
	beq check_left		; Skip move if zero/not pressed
	move_right:
		clc
		lda player_pos	; Load current position
		cmp #$A9	; Make sure it's not $A9
		beq no_add	; If it is, don't move!
		adc #1		; If it's not, add 1 to x-position
		sta player_pos	; Store in player_pos
		lda #%00000010
		sta $0202
		jsr animate_girl
check_left:
	lda player_buttons
	and #%01000000		; Bit 6 is "left"
	beq no_add		; Skip move if zero/not pressed
	moveleft:		; (Sim. to code above but for moving left)
		clc
		lda #$4F	; Don't move left past $4F (wall)
		cmp player_pos
		beq no_add
		lda player_pos	; Ok to move
		adc #255	; Add 255 (= -1) to position
		sta player_pos	; Store in player_pos
		lda #%01000010
		sta $0202
		jsr animate_girl
no_add:
	rts	


tick_updates:
	; check to add tick up (tick_down == 0; reset tick_down)
	; check to add max_items (tick_up == 5; reset tick_up)
	; check to decrease fall_frame_rate (tick_up == 5; reset tick_up)
	lda #60
	sta tick_down


	lda tick_up
	clc
	adc #1
	sta tick_up
	cmp #5		; Check to add new item drop
	bne keep_counting


	; Reset tick_up, update max_items, fall_frame_rate
	; and add one more bomb to item choices

	lda #0
	sta tick_up	; New minute begins

	ldx max_items
	cpx #7		; Check if 7 items already falling
	beq check_choices

	inx
	stx max_items	; One more item can fall now
	

	; Initialize the xth item
	; $0201 + (x*4) to get current tile
	txa
	rol
	rol
	tay
	jsr update_tile	
	
check_choices:
	lda item_choices
	cmp #%11100000	; Check if already hardest setting
	beq frame_update
	asl		; Rotate one more cake off list
	sta item_choices

frame_update:
	lda fall_frame_rate
	cmp #0
	beq keep_counting
	
	sec
	sbc #1		; One less frame before items move
	sta fall_frame_rate

keep_counting:
	rts	


update_tile:	
	ldx random_num2	; 1 of 8 choices for bomb/cake
	txa
	clc
	lsr
	clc
	lsr
	clc
	lsr
	clc
	lsr
	clc
	lsr		; Now only bottom 3 bits relevant (0-7)
	tax		; Transfer "random" number (0 to 7) to x


	lda item_choices	
	sta temp_pos
cake_or_bomb:
	lda temp_pos
	lsr
	sta temp_pos
	dex
	cpx #0
	bne cake_or_bomb
	
	lda temp_pos
	and #%00000001	; Keep only bottom bit
	cmp #1
	bne its_a_bomb

its_a_cake:
	lda #5
	jmp make_new_item
its_a_bomb:
	lda #2
make_new_item:	
	
	sta $0201,y
	lda #$30
	sta $0200,y		; Store starting y-coord
	
	lda #$02
	sta $0202,y

	lda random_num2		; Setup for "random" x-coord
	adc random_num1
	and #%00111111
	sta temp_pos
	clc
	adc #$5F		; Offset by at least $5F on screen

	sta $0203,y		; Store starting x-coord
	rts


collisions:

	
	; Check if the tile is active
	ldx #0
collision_loop
	inx
	txa
	asl
	asl
	tay

	lda $0201,y
	bpl player_collide	; All active tiles have value < 127 (positive)
	
	jmp finished_tile

player_collide:
	; Check if it's hitting player

	lda $0200,y
	sec
	sbc #$91	; Checking if y-coord is low enough
	bpl col_check	; Positive means it's at least that low


	jmp floor_collide
col_check:

	lda $0203,y
	sta temp_pos	; Store item x-position

	lda $0203	; Player x-position
	sec
	sbc temp_pos	
	bmi col_player_left


col_player_right:
	; Player is on the right side, which
	; makes subtraction necessarily positive		
	
	; subtract 6, will be negative if within 5 pixels
	
	sec
	sbc #6
	bmi connected		; Collision!
	jmp floor_collide

col_player_left
	; Player is on the left side, which
	; makes subtraction necessarily negative
	
	; add something from it that will make it
	; positive ONLY if it's less than 6:
	clc
	adc #5
	bpl connected		; Collision!
	jmp floor_collide

connected:
	lda $0201,y
	cmp #5
	bne boom		; Go boom if not a cake
cake_points:
	jsr update_score		; Points for cake!
	jsr update_tile
	jmp finished_tile
boom:
	lda #$50		; Player re-start
	sta player_pos
	lda player_lives		; Lose a life!
	sec
	sbc #1
	jsr lose_life
	bpl exploding_time

floor_collide:
	; Check if it's hitting floor
	lda $0200,y
	cmp #$98
	bmi finished_tile	; Negative means it's above this spot


	; Check to see if already exploding
	; Skip to next tile if so
	lda $0201,y
	cmp #3			
	beq finished_tile
	cmp #4
	beq finished_tile

exploding_time:
	
	lda $0201,y
	cmp #2		; Verify it's a bomb

	bne no_explode
	jsr do_explosion
	jmp finished_tile

no_explode:	
	jsr update_tile
	

finished_tile:
	
	cpx #8		; 8 possible falling tiles
	bne collision_loop

	rts


; Move items
move_items:

	ldx #0
	stx move_timer	; Reset move_timer
check_move:
	lda $2002
	inx
	txa
	
	; Multiply by four because
	; there are 4 attribs per tile
	asl
	asl	
	tay

	;0200-0203 y-coord, tile#, attrib, x-coord
	; First tile is player
	; Next 7 tiles are potential/actual items
	; Loop through them, if it's explosion 1,
	; set to explosion 2. If it's a bomb or a cake, 
	; move it down.

	
	lda $0201,y
	
	; Explosion tile 1 check
	cmp #$03
	bne exp2_chk	; If not explosion tile 1, chk tile 2
	jmp do_explosion	
exp2_chk:
	; explosion2 check
	lda $0201,y
	cmp #$04
	bne cake_bomb_chk	; If not explosion, check if cake/bomb


do_explosion:

	; Check if tile is bomb (starting new explosion)
	lda $0201,y
	cmp #2
	beq init_exp


	; Continuing explosion sequence
	; Subtract the relevant bit (there are three in total).
	; If all three are gone, stop being that kind of explosion
	; (if going from exp1 to exp2, go to init_exp)
	lda $0202,y
	cmp #%00000010
	beq bomb_anim1
	cmp #%00000011
	beq bomb_anim2
	cmp #%00100011
	beq bomb_anim3
	cmp #%01100011
	beq bomb_anim4
	
	lda $0201,y
	cmp #3
	beq init_exp
	jsr update_tile
	jmp done_moving

	;Bomb animation data
bomb_anim4:
	lda #%11100011
	sta $0202,y		
	jmp done_moving
bomb_anim3:
	lda #%01100011
	sta $0202,y		
	jmp done_moving
bomb_anim2:
	lda #%00100011
	sta $0202,y		
	jmp done_moving
bomb_anim1:
	lda #%00000011
	sta $0202,y
	jmp done_moving


	
init_exp:
	; Turn from bomb to explosion1,
	; or explosion1 to explosion2
	lda $0201,y
	clc
	adc #1
	sta $0201,y
	lda #%00000010
	sta $0202,y
	jmp done_moving


cake_bomb_chk:
	; If it's not an explosion,
	; it must be a bomb or cake,
	; so move it down
	
		
	lda $0200,y
	clc
	adc #1
	sta $0200,y
		

done_moving:	
	cpx max_items
	bne check_move

	rts


lose_life:
life3:
	lda $022D
	cmp #00
	bne life2
	lda #06
	sta $022D
	rts
life2:
	lda $0229
	cmp #00
	bne life1
	lda #06
	sta $0229
	rts

life1:
	jmp start_game


update_score:
	
	lda playerscore_lo
	clc
	adc #1
	sta playerscore_lo
	cmp #39
	bne no_add_carry
	lda #29
	sta playerscore_lo	; Reset to 0 (added 1 to 9)
	lda playerscore_mid
	clc
	adc #1
	sta playerscore_mid
	cmp #39
	bne no_add_carry
add_carry:
	lda #29
	sta playerscore_mid
	lda playerscore_hi
	clc
	adc #1
	sta playerscore_hi

no_add_carry:
	; Go to namespace address for score tiles
	; and update them

	lda $2002
	lda #$22 		
	sta $2006
	lda #$E9 		
	sta $2006
updating:
	lda playerscore_hi
	sta $2007
	lda playerscore_mid
	sta $2007
	lda playerscore_lo
	sta $2007
	lda #0
	sta $2005
	sta $2005
	rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Music and graphics data ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;


initial_palette:
	db $2A,$27,$0F,$1A  ; Background palettes
	db $2A,$23,$33,$1A
	db $2A,$22,$33,$1A
	db $2A,$27,$31,$1A
	db $0F,$0F,$27,$16  ; bomb palette
	db $0F,$27,$16,$11  ; cake palette
	db $0F,$07,$27,$25  ; girl palette
	db $0F,$2d,$16,$2d  ; extra palette


sprites:

	db $98, $00, $02, $78 ; Girl #1

; Background data
	
backgrounddata_walls:
	
	db $01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01

backgrounddata_words:
	db $09,$02,$11,$11,$1A			; HAPPY
	db $03,$0A,$13,$15,$09,$05,$02,$1A, $1C	; BIRTHDAY

score_lives_tiles:
	db $0D, $0A, $17, $06, $14	; LIVES
	db $14, $04, $10, $13, $06, $2C, $1D, $1D, $1D, $1D ; SCORE 0000

score_sprite:

	db $AE, $00, $02, $45 ; Girl #1
	db $AE, $00, $02, $4D ; Girl #1
	db $AE, $00, $02, $55 ; Girl #1



	org $FFFA
	dw nmi_handler
	dw start_game
	dw irq_handler

chr_rom_start:

background_tile_start:

	db %00000000	; "Blank" tile
	db %00000000
	db %00000000
	db %00000000
	db %00000000
	db %00000000
	db %00000000
	db %00000000
	db $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF	; bitplane 2

	db %11101110	; Brick tile
	db %11101110
	db %10111011
	db %10111011
	db %11101110
	db %11101110
	db %10111011
	db %10111011

	db %00010001	; bitplane 2
	db %00010001
	db %01000100
	db %01000100
	db %00010001
	db %00010001
	db %01000100
	db %01000100

	db %00000000	
	db %00011000	; "A"
	db %00100100
	db %01000010
	db %01000010
	db %01111110
	db %01000010
	db %01000010
	db $00, $00, $00, $00, $00, $00, $00, $00	; bitplane 2

	db %00000000
	db %11111000	; "B"
	db %10000100
	db %10000100
	db %11111000
	db %10001000
	db %10000100
	db %11111100
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %00111100	; "C"
	db %01000010
	db %10000000
	db %10000000
	db %10000000
	db %10000010
	db %01111100

	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %11100000	; "D"
	db %10010000
	db %10001100
	db %10000110
	db %10000110
	db %10011000
	db %11100000

	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000	; "E"
	db %11111110
	db %10000000
	db %10000000
	db %11111100
	db %10000000
	db %10000000
	db %11111110
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000	; "F"
	db %11111110
	db %10000000
	db %10000000
	db %11111100
	db %10000000
	db %10000000
	db %10000000
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %00111000	; "G"
	db %01000100
	db %10000000
	db %10000000
	db %10011100
	db %10000110
	db %01111100

	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000	; "H"
	db %10000010
	db %10000010
	db %10000010
	db %11111110
	db %10000010
	db %10000010
	db %10000010
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %11111110	; "I"
	db %00010000
	db %00010000
	db %00010000
	db %00010000
	db %00010000
	db %11111110
	db $00, $00, $00, $00, $00, $00, $00, $00


	db %00000000
	db %11111110	; "J"
	db %00010000
	db %00010000
	db %00010000
	db %00010000
	db %10010000
	db %01110000
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %10000010	; "K"
	db %10000100
	db %10011000
	db %11100000
	db %10100000
	db %10011000
	db %10000100

	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000	; "L"
	db %10000000
	db %10000000
	db %10000000
	db %10000000
	db %10000000
	db %10000000
	db %11111110
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %10000010	; "M"
	db %11000110
	db %10101010
	db %10010010
	db %10000010
	db %10000010
	db %10000010
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %10000010	; "N"
	db %11000010
	db %10100010
	db %10010010
	db %10001010
	db %10000110
	db %10000010

	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %01111100	; "O"
	db %10000010
	db %10000010
	db %10000010
	db %10000010
	db %10000010
	db %01111100
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %01111100	; "P"
	db %10000010
	db %10000010
	db %11111100
	db %10000000
	db %10000000
	db %10000000
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %01111000	; "Q"
	db %10000100
	db %10000010
	db %10000010
	db %10001010
	db %10000100
	db %01111010
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %00111000	; "R"
	db %11000100
	db %10000100
	db %11111100
	db %10001000
	db %10000100
	db %10000110
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %01111100	; "S"
	db %11000010
	db %10000000
	db %01110000
	db %00001100
	db %10000110
	db %11111100
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %11111110	; "T"
	db %00010000
	db %00010000
	db %00010000
	db %00010000
	db %00010000
	db %00010000
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %10000010	; "U"
	db %10000010
	db %10000010
	db %10000010
	db %10000010
	db %10000010
	db %11111110
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %10000010	; "V"
	db %10000010
	db %10000010
	db %10000010
	db %01000100
	db %00101000
	db %00010000
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %10000010	; "W"
	db %10000010
	db %10000010
	db %10000010
	db %10010010
	db %10101010
	db %01000100
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000	; "X"
	db %10000010	
	db %01000100
	db %00101000
	db %00010000
	db %00101000
	db %01000100
	db %10000010
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000	; "Y"
	db %10000010	
	db %01000100
	db %00101000
	db %00010000
	db %00010000
	db %00010000
	db %00010000
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %11111110	; "Z"
	db %00001100	
	db %00011000
	db %00110000
	db %01100000
	db %11000000
	db %11111110
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %00010000	; "!"
	db %00010000
	db %00010000
	db %00010000
	db %00000000
	db %00010000
	db %00010000
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %01111100	; "0"
	db %10000010
	db %10000010
	db %10000010
	db %10000010
	db %10000010
	db %01111100
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %00010000	; "1"
	db %00010000
	db %00010000
	db %00010000
	db %00010000
	db %00010000
	db %00010000
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %01111100	; "2"
	db %10000010
	db %00000100
	db %00001000
	db %00110000
	db %01000000
	db %11111110
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %01111100	; "3"
	db %10000010
	db %00000100
	db %00011000
	db %00000100
	db %10000010
	db %01111100
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %00001110	; "4"
	db %00010010
	db %00100010
	db %01111110
	db %00000010
	db %00000010
	db %00000010
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %11111110	; "5"
	db %10000000
	db %10000000
	db %11111000
	db %00000100
	db %10000010
	db %01111100
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %00010000	; "6"
	db %00100000
	db %01000000
	db %01111000
	db %10000100
	db %10000100
	db %01111100
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %11111110	; "7"
	db %00000100
	db %00001000
	db %00010000
	db %00100000
	db %01000000
	db %10000000
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %00011000	; "8"
	db %00100100
	db %01000010
	db %00111000
	db %01000100
	db %10000010
	db %01111110
	db $00, $00, $00, $00, $00, $00, $00, $00

	db %00000000
	db %00011000	; "9"
	db %00100100
	db %01000010
	db %00111110
	db %00000010
	db %00000010
	db %00000010
	db $00, $00, $00, $00, $00, $00, $00, $00

background_tile_end:
	ds 4096-(background_tile_end-background_tile_start)


sprite_tile_start:


	db %00000000	; "Person walk" (0)
	db %00011100
	db %00010000
	db %00010000
	db %00011100
	db %00001100
	db %00001100
	db %00010010

	db %00000000	; "Person walk bp2" 
	db %00000000
	db %00001100
	db %00001100
	db %00001100
	db %00001100
	db %00001100
	db %00000000

	db %00000000	; "Person standing" (1)
	db %00011100
	db %00010000
	db %00010000
	db %00011100
	db %00001100
	db %00001100
	db %00001100

	db %00000000	; "Person standing bp2"
	db %00000000
	db %00001100
	db %00001100
	db %00001100
	db %00001100
	db %00001100
	db %00000000

	db %00000000	; "bomb" (2)
	db %00001000
	db %00111100
	db %01111110	
	db %01111110	
	db %01111110	
	db %00111100	
	db %00000000


	db %00001000	; "bomb bp2"
	db %00000000
	db %00000000
	db %00000000
	db %00000000
	db %00000000
	db %00000000
	db %00000000	


	db %00000000	; "bomb explosion!" (3)
	db %00000000
	db %00000000
	db %00000000	
	db %00000000	
	db %00000000	
	db %00000000	
	db %00000000


	db %00000100	; "explosion bp2"
	db %01101010
	db %10111101
	db %01111111
	db %11111110
	db %10111111
	db %01111100
	db %00100110	

	db %00000100	; "bomb explosion! 2 (4)"
	db %01101010
	db %10111101
	db %01111111
	db %11111110
	db %10111111
	db %01111100
	db %00100110


	db %00000100	; "explosion bp2"
	db %01101010
	db %10111101
	db %01111111
	db %11111110
	db %10111111
	db %01111100
	db %00100110	


	db %00000000	; "Cake" (5)
	db %00000000
	db %00000000
	db %00111100	
	db %00111100	
	db %00111100	
	db %00111100	
	db %01111110


	db %00000000	; "Cake bp2"
	db %00000000
	db %00000000
	db %00000000
	db %00111100
	db %00000000
	db %00111100
	db %00000000	


sprite_tile_end

	
chr_rom_end:

; Pad chr-rom to 8k(to make valid file)
	ds 8192-(chr_rom_end-chr_rom_start)
		
	</code></pre>
	</div><!-- first file of accordion closed -->


	<h1>Explanation for the Game Code</h1>
	<div>
	<p id="explanation">
		Whew, that's a lot of code! But not to worry, we've already seen a lot of this code in the previous 
		tutorials, which I strongly recommend you go through if you haven't already. In fact, I'm going to 
		skip explanations about anything we've already covered in previous tutorials, instead focusing on the 
		new concepts or code introduced here.
	</p>

	<h2>More Labels (the "equ" stuff)</h2>
	<p>
		In this program, we've got a few more labels (all those lines with the "equ" in them). This is just 
		to make writing the code easier, as well as making it easier to read. The command 
		<span class="code">lda player_lives</span> is easier to grasp than <span class="code">lda $03</span> 
		(the address we've assigned to the label "player_lives"). You may also notice we've got multiple labels 
		referencing the same hex number - for example, player_lives is equal to $03, but so is C2 (in our music 
		notes just below). This is okay, because in one case we're using the label for an address to store 
		data ("player_lives"), and in the other case we're using it just to count something ("C2" is the 4th 
		note in a list of notes, hence the $03 - with $00 being the first number in our note name labels).
	</p>
	<p>
		By the way, there's a potential bug in the way we've labeled our music notes, both in this and the 
		music tutorial we did. It's very subtle, and it doesn't actually affect the way our code runs, but it 
		would if we were trying to use the first note in our note table, A1. We've labeled A1 as $00, but 
		we've also written in our code to stop playing music whenever we see a zero in our notes. See the 
		problem? If we wanted to play an A1, our code would stop the sound instead. There are a few ways to 
		fix this issue, which I will leave to you as a challenge if you so desire, but since it doesn't 
		actually affect the program, I'm going to leave it as is.
	</p>

	<h2>The NMI Handler</h2>
	<p>
		There are quite a few changes in our nmi_handler, so let's go over them briefly here, then we'll do a 
		deeper dive on each section of it. First we use "php" and "pha" to store our variables and flags until 
		after the nmi (we use "plp" and "pla" at the end to retrieve those values). Then we load the position 
		of our player ("player_pos") and store it in $0203, followed by refreshing our sprite data by storing 
		#$02 into $4014. We've gone over why we do this in previous tutorials, but I did want to point out 
		that I've put this at the beginning of our nmi because graphic updates should generally come first. If
		your nmi has too much code, there is a chance that your graphics won't load before another nmi is 
		loaded (in fact, my original code had this at the end of my nmi, and I was getting some flickering 
		with my sprites that no longer seems to be happening).
	</p>
	<p>
		Next, we have the code that checks the current note being played ("ct_note") and plays the next note 
		("play_note") if there are more to be played. Again, we've already seen this in the music tutorial, so 
		we'll skip the details here. After that, we have a "jsr" command to our "read_controller" function, 
		which is very similar to our controller tutorial, but with some changes I'll outline shortly. After 
		the music and controller reading, we finally get to the new code in our nmi. We increase our 
		"move_timer" by using "inx", and we decrease our "tick_down" by using "dex". We check if "tick_down" is 
		0, and if it is, we go to our "tick_updates" function; otherwise we continue along to "chk_collisions" 
		to see if any collisions have occurred.
	</p>
	<p>
		Next, in our "chk_frame_rate" section of our nmi, we see if move_timer is equal to fall_frame_rate, and 
		if it is, we reset it and call our "move_items" subroutine. After that, we go to the "randomizer" 
		section of our code to generate some random numbers, which we use for anytime we need to generate a 
		new falling item, or a new x-coordinate for that item. I am sure there are better ways to randomize 
		numbers, so if you're looking for random numbers, you could probably do better than what I have here. 
		However, it is "random enough" for this game - I can't predict when the game will pick a bomb or a 
		cake as the next falling item, nor can I guess where it will fall. Sometimes perfect is the enemy of 
		good enough, and I'll settle for good enough here.
	</p>
	<p>
		That takes us through the overview of our nmi. I will go over each new function or subroutine in more 
		detail as it comes up in the code, but at least now we have a broad idea of how everything runs in 
		the nmi.
	</p>

	<h2>Initializing Lives and Score</h2>
	<p>
		A large chunk of the code that follows has already been explained in prior tutorials, so we'll skip 
		down to "lives_and_score", which is where we are putting the tiles for lives and score, as the name 
		would suggest. Most of what is here is similar to previous graphics code. The only thing of interest 
		to note is the "score_sprites" section, where we are using our character sprite as the marker for the 
		number of lives. It's the only part of our background that isn't technically made up of background 
		tiles.
	</p>

	<h2>Initializing Game Data</h2>
	<p>
		In our next section we're loading up all the starting values for our game. It's here you can really 
		start to appreciate the use of labels, as it's much easier to understand what our data represents 
		this way. Most of the numbers here are pretty self-explanatory: 3 lives stored in "player_lives", 60 
		stored in "tick_down" (because there are about 60 screen refreshes per second). We set "fall_frame_rate" 
		to 15 (the number of frames before a falling item moves down one pixel). We start with "max_items" at 1
		because we only want one falling item to start, but more will be added later, as we will see. The 4 we 
		store in "walk_animation" was because I wanted to change our player sprite tile from tile #0 to tile #1 
		(or vice versa) for every 4 frames of walking - but as it turns out, I ended up using more than 4 
		frames for the animation. We'll go over that in more detail later, but the value 4 stored here works 
		well enough for our purposes.
	</p>
	<p>
		The next eight lines of code are to set up the details of our first falling item, which is a cake. As 
		you'll see in our code, and you may 
		have noticed in our graphics tutorial, our layout for sprite data (which starts at $0200) goes like 
		this: y-coordinate for sprite 0, tile #, special attributes (horizontal/vertical flip, palette choice, 
		etc), and x-coordinate for sprite 0. Then it repeats for the next sprite. So $0201 is the tile # for 
		sprite 0, $0205 is the tile # for sprite 1, $0209 for sprite 2, etc. This knowledge will come in handy 
		later in the program.
	</p>
	<p>
		The next chunk of code is identical to our music tutorial, as it's just the setup for our instruments 
		and first note. Following that are all the datum for the music notes, their length, and so on, so 
		we'll skip that code because we've already gone over it in our tutorial on sound.
	</p>

	<h2>Walking Animation ("animate_girl")</h2>
	<p>
		Here is our first new subroutine, which is all about whether or not to "animate" the player sprite. 
		First we load the value from "walk_animation" (which starts at 4). We use "sec" and "sbc" commands to 
		subtract 16 (reminder: we need to use "sec" to set the carry, or our subtraction will be off by one). 
		If the result sets the negative flag (i.e. any number between 128 and 255), we load up the tile value 
		for our sprite. If it's zero, our "beq" command sends us to "walk_now", which loads up tile #1 (the 
		walking tile of the player sprite). Otherwise, we load tile #0, our standing tile, and make that the 
		new tile.
	</p>
	<p>
		Basically, the gist of this code is that, every time we move left or right, we call "animate_girl" and 
		subtract 16 from "walk_animation". Because 255/16 = 16, basically every eight frames of walking results 
		in a change of animation, since 0 to 127 is positive, and 128 to 255 sets the negative flag. I 
		originally tried to do this with only 4 frames (which is why I loaded 4 into "walk_animation"), but it 
		was too quick. It's a weird bit of code, but it updates the animation at a rate I'm happy with, so I 
		left it as is. I'm sure something better could be written here - and I think that a larger character 
		or larger/longer animation would probably be better.
	</p>

	<h2>Controller Logic ("read_controller")</h2>
	<p>
		This section of code is almost identical to our controller input tutorial, but there are two small 
		changes. The second we've already gone over, which is the jump to subroutine "animate_girl". The two 
		lines before that in the "check_right" and "check_left" secions, would be the first change:
	</p>
	<pre><code>
	lda #%01000010
	sta $0202
	</code></pre>
	<p>
		The first "1" in %01000010 turns on the horizontal flip, i.e. the sprite is now facing left instead of 
		right. For "move_right", it's a zero, so that our girl faces right again anytime we move to the right.
	</p>

	<h2>Time Keeps on Tickin... ("tick_updates")</h2>
	<p>
		Our "tick_updates" subroutine is called after every 60 nmis (i.e. when our "tick_down" reaches zero). We 
		refresh our tick_down and set it to 60, and then we add 1 to "tick_up". When "tick_up" reaches 5 (which 
		is approx. every 5 seconds), we reset it to zero, and then load "max_items" into our accumulator. We 
		check if it's equal to 7; if it isn't, we add 1 to it ("inx"), and then we initialize a new item. We 
		do this by first transferring our x value to our accumulator. Now our accumulator is set to whatever 
		number of item we are adding. We use "rol" twice on it, which effectively multiplies it by 4, then we 
		transfer that value to our y-register, and call the "update_tile" subroutine, which we'll go over 
		shortly.
	</p>
	<p>
		This brings us to "check_choices", which is where we check to see "item_choices" to see what can be 
		chosen for our new items. Every bit set to 1 in "item_choices" represents a cake, and every zero 
		represents a bomb - you'll see how when we look over "update_tile" in a bit. "item_choices" starts out 
		as %11111111, or all cakes, but every time we check it here, we use one "asl" to rotate it, so we 
		eventually get %11111111 -> %11111110 _> %11111100, etc. I.e. we get one less cake everytime, until we 
		have %11100000. This means we are slightly more likely to get a bomb as our new item than we are to 
		get a cake. After some testing this was the value I was happy with - I originally started with 
		%10000000 being the last value of "item_choices", which meant that about 90% of the items dropping were 
		bombs! 
	</p>
	<p>
		The last thing we do is check "fall_frame_rate" - if it's not already zero, we subtract one more from 
		it, which makes item drops faster. We are now finished our "tick_updates" subroutine.
	</p>

	<h2>Tile Updates ("update_tile")</h2>
	<p>
		Here we finally make use of our random numbers, stored in "random_num2" and "randomnum", respectively. 
		We take "random_num2", store it in our accumulator, and we use "lsr" (with "clc") to continually 
		rotate it to the right. We do this five times, which results in a number that is guaranteed to have 
		the five highest numbers as all zeroes. In other words, we now have a "random" number between zero and 
		seven. We store this number in our x-register, and then we load "item_choices" and store that into 
		"temp_pos" (a variable to temporarily store a number). Now we perform a loop where we rotate the values 
		that we had in "iteamchoices" (which has "1" for cakes and "0" for bombs), until we've rotated it a 
		number of times equal to that random number from one to eight. Then we take that result and we keep 
		only the zero bit (or lowest bit) by using "and #%00000001". This number will either be one or zero; 
		if it's zero, it's a bomb, and if it's one, it's a cake. We go to the appropriate section ("its_a_cake" 
		or "its_a_bomb") and load the appropriate tile value (5 for cake, 2 for bomb). We then store that in 
		$0201 + y (we stored an appropriate y value in the register before we called the "update_tile" 
		function) to give us the new tile. We reset the y-coordinate to #$30, we pick the appropriate palette 
		value and store it in $0202 + y, and then we add "random_num1" and "random_num2" together, finally using 
		"and %00111111" on that value, and using that + #$5F to get our new x-coordinate ($5F is the left-most 
		wall of our building). We're now finished updating the tile and we use "rts" to exit the subroutine.
	</p>

	<h2>Collisions</h2>
	<p>
		Here's the function we use to check if any of the falling items have struck either the player or the 
		floor. The first thing we do is check if we're dealing with an active tile. During our start_game/reset 
		we made sure to set all of our tile properties to #$FF with the following code:
	</p>
	<pre><code>
	lda #$FF
	sta $0200,x	; Load $FF into $0200 to hide sprites
	</code></pre>
	<p>
		What this means is that, at least when the game is turned on, every tile is place at y-coordinate #$FF 
		(which is offscreen), and that every one of our 64 sprites is set to tile #$FF (which is a blank tile, 
		since we didn't actually make a 255th sprite tile). Since #$FF is considered a negative number, we 
		simply check every tile to see if it's positive. If it isn't, we skip to the end of our loop 
		("finished_tile"), because it's not an active tile.
	</p>
	<p>
		What do we do if it's a "positive" numbered tile? First, we check whether it is colliding with the 
		player ("player_collide"). We load the y-coordinate of the tile using "lda $0200,y". Then we subtract 
		#$91, which is the y-coordinate just above the player's head. If this subtraction is positive, that 
		means the y-coordinate of the falling item is lower than that, so there might be a collision - we just 
		need to see if the x-coordinates are close enough, which we do by branching to "col_check".
	</p>
	<p>
		In "col_check" we load the x-coordinate of the falling tile, and we store it in "temp_pos". We then load 
		our player's x-coordinate, and subtract "temp_pos" from it. If the value is negative, then our item is 
		further to the right, so we check for collision using "col_player_left". Otherwise, we check using 
		"col_player_right". The logic for these parts may seem a bit strange, but bear with me a moment. For 
		"col_player_right", the player is to the right of the item, which means our subtraction was positive. 
		We now subtract once again by 6, which, if it gives a negative value, means that the distance between 
		those two objects was less than six pixels apart, so we consider this a collision (you can try 
		substituting different numbers here to see what you think is a good number to check for collision - 
		6 seemed just right to me). We follow a similar logic for "col_player_left", but add 5 instead (since 
		our subtraction would have given a negative result).
	</p>
	<p>
		Our next section of code, "connected", checks to see what kind of item we've collided with. We load up 
		#5 (tile # for cake). If it's anything other than that (which we check with "bne"), we branch to 
		"boom" (where bad things happen to our player). Otherwise it's a cake and we go to "cake_points", where 
		we call our "update_score" routine (more on that soon), and then we call our "update_tile" function, and 
		then jump to "finished_tile" to end this iteration of the loop.
	</p>
	<p>
		The "boom" section of our code... where good players go to get blown up, unfortunately! Here we reload 
		the player's position to #$50 (the left side of the building), and we subtract a life from 
		"player_lives". After that we call our "lose_life" subroutine (more on that shortly), and then we move 
		on to "exploding_time", where we animate our bomb explosion.
	</p>
	<p>
		Before we blow anything up, however, we need to talk about our "floor_collide" section of this 
		function, which we go to anytime we call this function and aren't connecting with the player. We check 
		#$98 (the y-coordinate of the floor) using "cmp #$98". If this sets the negative flag, that means that 
		our y-coordinate of our falling item is less (higher up), so we branch to "finished_tile" with no 
		collision. Otherwise, we have collided with the floor, and we check if our bomb is already exploding 
		or not with:
	</p>
	<pre><code>
	lda $0201,y
	cmp #3
	beq finished_tile
	cmp #4
	beq finished_tile
	</code></pre>
	<p>
		Tiles #3 and #4 are our explosion tiles, and if either is the current tile, we leave that item alone 
		(we handle our explosion animation elsewhere, as we'll see shortly). Otherwise, we are now in 
		"exploding_time", where we verify that our tile is a bomb with "cmp #2", and if it is, we go to 
		"do_explosion" (which is in our "move_items" function/section of the program). If an explosion is not 
		required, we call our "update_tile" function (we have collided and thus need a new item at the top of 
		the screen).
	</p>
	<p>
		The last section of this function is "finished_tile", which checks if we've looped through all of our 
		items with a "cpx #8", and if it has, we use "rts" to exit the function.
	</p>

	<h2>Moving Time ("move_items")</h2>
	<p>
		We now look at our code to actually move all of our falling items. We load zero into our x-register, 
		which we use both to reset "move_timer" and to loop through our items. We increase x to 1, and then use 
		similar multiplication tricks to ones we used earlier, so we can loop through the tile numbers of each 
		sprite. We check if the tile is an explosion by using "cmp #$03"; if it is not, we check if it's our 
		second explosion tile in "exp2_chk". If it isn't that either, we go to "cake_bomb_chk" where we move the 
		tile down by one pixel (because if it isn't an explosion, it must be a bomb or a cake, so we can move 
		it).
	</p>
	<p>
		If our tile was an explosion, we then perform the code in our "do_explosion" section. Here the first 
		thing we do is check to see if the tile is a bomb. Wait a minute, why would we do that? Didn't I just 
		finish saying that if it's not an explosion, it must be a cake or bomb and move down 1 pixel? It 
		should, unless we call "do_explosion" from our "collisions" subroutine, which we do if a bomb hits 
		either the floor or our player. So if it's a bomb here, then that means we are dealing with a 
		collision, so we go to "init_exp" to initiate our explosion. Otherwise, what we have is a series of 
		checks to see what phase of our animation we are in ("bomb_anim4", "bomb_anim3", "bomb_anim2", and 
		"bomb_anim1"). Basically each of these is a slight variation on the last, and we're modifying one of a 
		few things: the horizontal flip, the vertical flip, or whether the sprite has priority (should show up 
		in front of the background or not). By modifying each one differently for each animation call, we get 
		a slightly different tile each time, which is what makes our explosion animation. Cool!
	</p>
	<p>
		Our "init_exp" is the section we call if have either a bomb that's about to explode, or our first 
		explosion tile has finished its animation (look carefully at the section after "beq bomb_anim4"; it's a 
		check to see if the tile is explosion tile 1, and if so, to move to "init_exp"). Here we add one to our 
		tile (turning bomb into explosion tile 1, and explosion 1 into explosion tile 2), we store that value, 
		and then we set the appropriate attribute values in $0202 + y to begin our animation.
	</p>
	<p>
		As mentioned above, we are now at "cake_bomb_chk", where we move either our cake tiles or an unexploded 
		bomb tile down by 1 pixel. We then move on to "done_moving" where we check if we've finished our loop, 
		and if so, we "rts" back to where we left off. There's something worth pointing out here. Because we 
		can call our "do_explosion" section from "collisions", we have a weird circumstance where we sort of 
		jump mid-loop into another loop. In other words, when a collision occurs that requires an explosion, 
		we jump from wherever we were in that loop to a different loop, which we would then complete. What 
		does that mean for the logic of our code? Basically it means we won't actually finish our collision 
		loop properly. This shouldn't be a serious problem, because the code is written so that it can catch 
		any bombs we missed the next time around. But if the game were more complex, it could cause problems 
		where we miss collisions - in fact, I originally had collisions with the floor checking exactly one 
		pixel, and if it wasn't at that pixel, then the collision wouldn't occur. This resulted in some bombs 
		falling through the floor! We must always be careful about the logic of our code, and while my 
		solution seemed to fix it, there probably is a cleaner way to write the logic of my code so that this 
		couldn't happen ("do_explosion" could exist independently of both "collide" and "move_items" which is 
		one potential solution to this problem).
	</p>

	<h2>Coping with Loss ("lose_life")</h2>
	<p>
		Here we deal with the sad reality that is exploding and losing a life. It happens! The code here is 
		pretty straighforward. We check each space where there should be a sprite representing one of our 
		lives, starting with the third one. If a sprite is there, we remove it, and we exit the subroutine. If 
		there isn't a sprite there, we move to the next life. If only one life remains when the function is 
		called, we reset the game by using "jmp start_game". In a "real" game it would probably be better to 
		throw a "game over" up on the screen with some sad music, before resetting the game, but bear in mind 
		this is just a game demo - I'll leave it to you to make the next smash NES hit!  
	</p>

	<h2>Updating the Score ("update_score")</h2>
	<p>
		We have reached our final subroutine, which, as the name would suggest, adds to our score. We start by 
		loading the low digit of our score (technically the second lowest digit, because we never modify the 
		lowest digit). We add 1 to whatever the digit is (more specifically, the tile # for that digit). If 
		the result is 39, we have reached our zero digit, and thus we need to carry 1 to the next digit, so we 
		now load our second score digit and repeat the process. We add 1 and if we reach 39 (the zero digit 
		tile), we add 1 to our high score.
	</p>
	<p>
		After all is said and done, we use our newly updated score to update the tiles that represent those 
		digits, and after that we reset our scroll by loading 0 into $2005 twice. If we don't do this, our 
		screen's background will scroll, becuase $2005 and $2006 share a register - so basically anytime you 
		use $2006, you are potentially messing up the scrolling register, since it's the same. Always remember 
		to reset the scroll after you update your background!
	</p>
	<p>
		Beyond that, there is nothing really new to discuss in the program. We have our data for various 
		sections such as the palette, sprites, background, and so on, and after that we have our definitions 
		for our reset, irq, and nmi vectors, followed by our CHR-ROM (the tiles) data. And that's it! Your 
		first real NES game - how exciting!
	</p>

	<h2>Final Notes about Birthday Blast</h2>
	<p>
		A few things I'd like to say about this program. While I am proud of having made it, 
		<span class="important">I make no claim that this program is optimized. In fact, I am fairly certain 
		that it isn't, and that several changes could be made to clean up the code.</span> Having said that, 
		my intent was to write a program that was fairly easy to read and understand, at least after having 
		done the other tutorials. I hope I've done that, and that this code will help you to realize your own 
		dream of making NES games. I loved playing Nintendo as a kid, and hoped that one day I could make my 
		own games, so crafting these examples for you is really a win-win: you learn something new, and I 
		bring joy to my inner child!
	</p>
	<p>
		A final caution: in general, don't put all or most of your code in your NMI when making your own 
		games. If there is too much code in your NMI, there is a risk that it won't all run before another 
		screen refresh is triggered. There are ways around this, but this subject is a little beyond the scope 
		of these tutorials. I will, however, leave you with a few links on the subject that you should check 
		out in your own time, after you feel you've gotten a good grasp of what I've taught you:

		<a href="https://www.nesdev.org/wiki/NMI_thread">NMI thread on nesdev.org</a>
		<a href="https://www.nesdev.org/wiki/The_frame_and_NMIs">The frame and NMIs (also on nesdev.org)</a>
	</p>
	<p>

		If you've made it this far, pat yourself on the back - you've done a great job! Even if you're 
		getting a little bit stuck on this tutorial (or one of the others), you should be proud of your 
		progress. And don't give up! Just keep reviewing the code, while strengthening your knowledge of 
		ASM6502 programming, and learn what you can about the NES hardware and how it works. All of these 
		moving pieces can seem a bit complex when taken as a whole, but as you keep absorbing new information 
		about the system and how to code for it, it all starts to make sense. Trust me! You will eventually 
		understand what you need to, to find success in writing your own programs. Don't be afraid to 
		experiment, modify the programs, and ask yourself good questions as to why things work the way they 
		do. Before you know it, you'll be teaching me how to write your NES programs!
	</p>
	</div><!-- second file of accordion closed -->
	<h1>Javascript App: NES Tile Maker!</h1>
	<div>
		<p id="javascript"></p>
	</div><!-- third file of accordion closed -->
	</div><!-- accordion closed -->

	<h1>"Where Do I Go From Here?"</h1>
	<p>
		As I said, you've done an excellent job if you've come this far - but don't stop now! There's always 
		more to learn, and plenty you can take in to grow as a programmer, and to make better games. For 
		starters, if you haven't already, be sure to look at the list of commands on the "Command Table" 
		page here:
		<a href = "commands.html">Command Table</a>
	</p>
	<p>
		Then, if you've done that, and feel like you've begun to get a handle on all the different commands 
		the ASM 6502 has to offer, be sure to look at the resources that I recommend from other sites, which 
		you can find here:
		<a href = "resources.html">Other Resources</a>
	</p>
	<p>
		Your journey as an NES programmer is well on its way. Keep it up! You're doing great, and I look 
		forward to seeing what kind of programs you create.
	</p>

	<div class="footer">
		<ul>
			<li><a href="index.html">Home</a></li>
			<li><a href="hardware.html">Hardware Basics</a></li>
			<li><a href="coding.html">Coding Basics</a></li>
			<li><a href="programs.html">Sample Programs</a></li>
			<li><a href="commands.html">Command Table</a></li>
			<li><a href="resources.html">Other Resources</a></li>
				
		</ul>
		<p>
			Â© 2023 Thomas Wesley Scott
		</p>
	</div><!-- Closing footer -->
</body>


<!-- JS SCRIPTS -->

<!-- JS begins loading, increment progress bar -->
<script type="text/javascript" src="scripts/beginLoad.js"></script>


<!-- Inspired by https://jqueryui.com/menu/#default
 (but no actual code was just used from the site) -->
<script type="text/javascript" src="scripts/hideProgMenu.js"></script>

<!-- Include jQuery! -->
<script type="text/javascript" src="scripts/jquery.js"></script>

<!-- // This script is from https://jquerypp.com/#cookie -->
<script type="text/javascript" src="scripts/cookie.js"></script>

<!-- This script is from https://jqueryui.com/ -->
<script type="text/javascript" src="scripts/jquery-ui-1.13.2.custom/jquery-ui.js"></script>

<!-- Darkmode script and NESTileMaker -->
<script type="text/javascript" src="scripts/darkMode.js"></script>
<script type="text/javascript" src="scripts/NESTileMaker.js"></script>

<!-- JS is done loading, finish loading animation -->
<script type="text/javascript" src="scripts/endLoad.js"></script>

</html>